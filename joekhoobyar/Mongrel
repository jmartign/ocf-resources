#!/bin/sh
#
# Description:	Directly manages a Mongrel instance as a High-Availability OCF resource
#								agent running on a Heartbeat/LinuxHA cluster.
#
# Author:		Joe Khoobyar <joe@ankhcraft.com>
# License:	GNU General Public License (GPL) version 2
# Copyright (c) 2009 All Rights Reserved
#
#
# See usage() function below for more details...
#
# OCF instance parameters:
#   OCF_RESKEY_mongrel
#   OCF_RESKEY_config
#   OCF_RESKEY_only
#   OCF_RESKEY_monitor_url
#		OCF_RESKEY_options
#   OCF_RESKEY_renice

#######################################################################
# Initialization:

. ${OCF_ROOT:-/usr/lib/ocf}/resource.d/heartbeat/.ocf-shellfuncs
. $(dirname $0)/.jk-shellfuncs

#######################################################################

: ${OCF_RESKEY_mongrel="/usr/bin/mongrel_rails"}
: ${OCF_RESKEY_verify_start=1}

usage() {
cat <<END

usage: $0 (start|stop|status|monitor|meta-data|validate-all)

$0 manages Mongrel as an OCF resource.

The 'start' operation starts Mongrel.
The 'stop' operation stops Mongrel.
The 'status' operation reports whether Mongrel is running.
The 'monitor' operation reports whether Mongrel seems to be working.
The 'meta-data' operation reports the configuration options.
The 'validate-all' operation reports whether the parameters are valid.

END
}

meta_data() {
cat <<END

<?xml version="1.0" ?>
<!DOCTYPE resource-agent SYSTEM "ra-api-1.dtd">
<resource-agent name="Mongrel">
    <version>1.0</version>
      <longdesc lang="en">This is an OCF resource agent for the Mongrel web server</longdesc>
      <shortdesc lang="en">OCF resource agent for Mongrel</shortdesc>
      <parameters>
				<parameter name="mongrel" required="1" unique="0">
					<longdesc lang="en">
						Full path to the Mongrel executable.
					</longdesc>
					<shortdesc>Mongrel executable</shortdesc>
					<content type="string" default="/usr/bin/mongrel_rails"/>
				</parameter>
				<parameter name="config" required="1" unique="0">
					<longdesc lang="en">
						Full path to the Mongrel configuration file for this instance.
					</longdesc>
					<shortdesc>Config file</shortdesc>
					<content type="string" default=""/>
				</parameter>
				<parameter name="only" required="0" unique="1">
					<longdesc lang="en">
						This Mongrel is a member of a mongrel cluster, analogous to
						using the --only flag to the cluster::start mongrel command.
					</longdesc>
					<shortdesc>Only one port</shortdesc>
					<content type="string" default=""/>
				</parameter>
				<parameter name="monitor_url" required="0">
					<longdesc lang="en">
						Optional URL to use for monitoring Mongrel with wget when the
						OCF_CHECK_LEVEL is 10 or above.
					</longdesc>
					<shortdesc>URL to monitor</shortdesc>
					<content type="string" default=""/>
				</parameter>
				<parameter name="options" required="0">
					<longdesc lang="en">
						Any additional options to pass to the Mongrel command.
					</longdesc>
					<shortdesc>Extra options</shortdesc>
					<content type="string" default=""/>
				</parameter>
				<parameter name="renice" required="0">
					<longdesc lang="en">
						Optional value to pass to renice Mongrel with after starting it.
					</longdesc>
					<shortdesc>renice value</shortdesc>
					<content type="string" default=""/>
				</parameter>
		</parameters>
    <actions>
      <action name="start" timeout="30" />
      <action name="stop" timeout="30" />
      <action name="status" timeout="20" />
      <action name="monitor" depth="0" start-delay="10" interval="10" timeout="30" />
      <action name="meta-data" timeout="5" />
      <action name="validate-all" timeout="5" />
   </actions>
</resource-agent>

END
}

mongrel_yml_to_vars() {
	local key value config="$1"
	[ -z "$config" ] && config="$OCF_RESKEY_config"
	[ -z "$config" ] && exit $OCF_ERR_ARGS

	# Read all of the values from YML in a chap manner.
	while IFS=" " read key value; do
		key=${key#:}
		key=${key%:}
		[ "${key:0:1}" = "-" ] && continue
		[ -z "$value" ] || eval "export MONGREL_${key}=${value}"
	done <"$config"

	# Validate cluster membership a bit up front.
	if ! [ -z "$OCF_RESKEY_only" ]; then

		if [ -z "$MONGREL_port" ] || [ -z "$MONGREL_servers" ]; then
			ocf_log err "Either port or the servers setting is invalid in $OCF_RESKEY_config"
			exit $OCF_ERR_ARGS
		fi

		let MONGREL_port_max=$((MONGREL_port + $MONGREL_servers - 1))

		if [ $OCF_RESKEY_only -gt $MONGREL_port_max ] || [ $OCF_RESKEY_only -lt $MONGREL_port ]; then
			ocf_log err "The 'only $OCF_RESKEY_only' parameter conflicts with the port and the servers setting(s) in $OCF_RESKEY_config"
			exit $OCF_ERR_ARGS
		fi

		# Create the "real" port, log_file, pid_file settings from the cluster settings.
		let MONGREL_port_min=$OCF_RESKEY_port
		let MONGREL_port=$OCF_RESKEY_only
		MONGREL_log_file=${MONGREL_log_file%.*}.${MONGREL_port}.${MONGREL_log_file##*.}
		MONGREL_pid_file=${MONGREL_pid_file%.*}.${MONGREL_port}.${MONGREL_pid_file##*.}

		# Differing commands for clustered vs. single mongrels.
		MONGREL_start="$OCF_RESKEY_mongrel cluster::start -C $OCF_RESKEY_config --clean --only $MONGREL_port $OCF_RESKEY_options"
		MONGREL_stop="$OCF_RESKEY_mongrel cluster::stop -C $OCF_RESKEY_config --clean --only $MONGREL_port $OCF_RESKEY_options"
	else
		MONGREL_start="$OCF_RESKEY_mongrel start -C $OCF_RESKEY_config -l $MONGREL_log_file -P $MONGREL_pid_file -c $MONGREL_cwd -r $MONGREL_docroot -d $OCF_RESKEY_options"
		MONGREL_stop="$OCF_RESKEY_mongrel stop -P $MONGREL_pid_file -c $MONGREL_cwd"
	fi

	MONGREL_force_stop="$OCF_RESKEY_mongrel stop -P $MONGREL_pid_file -c $MONGREL_cwd -w 45 -f"
	MONGREL_kill="( cat $MONGREL_pid_file | xargs kill -9 ) && rm -f $MONGREL_pid_file"
}

mongrel_validate() {
	[ -z "$MONGREL_log_file" ] || jk_validate_writable "$MONGREL_log_file"
	[ -z "$MONGREL_pid_file" ] || jk_validate_writable "$MONGREL_pid_file"
	[ -z "$MONGREL_address" ] || jk_validate_ip "$MONGREL_address"
	[ -z "$MONGREL_cwd" ] || jk_validate_directory "$MONGREL_cwd"
	if [ -z "$MONGREL_port" ] || ! ocf_is_decimal "$MONGREL_port"; then
		exit $OCF_ERR_CONFIGURED
	fi
  if [ -z "$MONGREL_user" -a -n "$MONGREL_group" ] || [ -z "$MONGREL_group" -a -n "$MONGREL_user" ]; then
		ocf_log err "You can't specify a user without a group or vice-versa."
		exit $OCF_ERR_CONFIGURED
	fi

	return $OCF_SUCCESS
}

mongrel_status() {
	jk_resource_status_by_pid 'Mongrel' "$MONGREL_pid_file"
}

mongrel_monitor() {
	local retval
	mongrel_status; retval=$?
	if [ $retval -eq 0 -a $OCF_CHECK_LEVEL -ge 10 ]; then
		jk_monitor_url
	else
		return $retval
	fi
}

mongrel_start() {
	local retval
	if mongrel_status; then
		ocf_log debug "Mongrel is already running"
		return $OCF_SUCCESS
	fi

	ERRORS=`$MONGREL_start 2>&1`; retval=$?

	if [ $retval -ne $OCF_SUCCESS ]; then
		[ -z "$ERRORS" ] && ERRORS="error code $retval"
		ocf_log err "Mongrel failed to start: $ERRORS"
		return $OCF_ERR_GENERIC
	else
		[ -z $OCF_RESKEY_renice ] || renice $OCF_RESKEY_renice $MONGREL_pid_file || true
	fi

	jk_verify_start_by_pid 'Mongrel' $MONGREL_pid_file
}

mongrel_stop() {
	local retval
	mongrel_status || return $OCF_SUCCESS

	# Try really hard to kill this mongrel...
	ERRORS=`$MONGREL_stop 2>&1`; retval=$?
	if [ $retval -ne $OCF_SUCCESS ]; then
		ERRORS="$ERRORS -- `$MONGREL_force_stop 2>&1`"; retval=$?
		if [ $retval -ne $OCF_SUCCESS ]; then
			ERRORS="$ERRORS -- `$MONGREL_kill 2>&`"; retval $?
			[ $retval -eq 0 ] && return 0
		fi
	fi

	if [ $retval -ne $OCF_SUCCESS ]; then
		[ -z "$ERRORS" ] && ERRORS="error code $retval"
		ocf_log err "Mongrel failed to stop: $ERRORS"
		return $OCF_ERR_GENERIC
	fi
}

# Do this first, in case some settings are bad.
if [ "$1" = "meta-data" ]; then
	meta_data; exit $OCF_SUCCESS
fi

# We always need these before we can do anything else...
jk_validate_executable "$OCF_RESKEY_mongrel"
jk_validate_readable "$OCF_RESKEY_config"
mongrel_yml_to_vars

# What kind of method was invoked?
case "$1" in
  start)	mongrel_validate; mongrel_start;;
  stop)		mongrel_stop;;
  status)	mongrel_status;;
  monitor)	mongrel_monitor;;
  validate-all)	mongrel_validate; exit $OCF_SUCCESS;;
  *)		usage; exit $OCF_ERR_UNIMPLEMENTED;;
esac
exit $?
